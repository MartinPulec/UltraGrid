///
/// @file    t2_cpu_codewords.h
/// @author  Martin Jirman (martin.jirman@cesnet.cz)
/// @brief   Coding of variable size codewords in JPEG2000 packets.
///


#ifndef T2_CPU_CODEWORDS_H
#define T2_CPU_CODEWORDS_H



/// For numbers from 0 to 255, this stores number of bits needed for 
/// the representation of the number (for 0, this intentionaly stores 1 bit)
static const char bit_size_lut[256] = {
    1, // 0
    1, // 1
    2, 2, // 2, 3
    3, 3, 3, 3, // 4 to 7
    4, 4, 4, 4, 4, 4, 4, 4,  // 8 to 15
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,  // 16 to 31
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // 32 to ...
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // ...   63
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // 64 to ...
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // ...
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // ...
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // ...   127
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // 128 to ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,  // ...
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8   // ...   256
};



/// For 32bit unisnged number, this gets the number of bits needed to represent 
/// it. For zero, this intentionaly returns 1.
inline int bits_needed(unsigned int n) {
    const int n_upper_16b = n >> 16;
    if (n_upper_16b) {
        const int n_upper_8b = n_upper_16b >> 8;
        return n_upper_8b
                ? 24 + bit_size_lut[n_upper_8b]
                : 16 + bit_size_lut[n_upper_16b];
    } else {
        const int n_byte_1 = n >> 8;
        return n_byte_1
                ? 8 + bit_size_lut[n_byte_1]
                : bit_size_lut[n];
    }
}



/// Stores stuff related to pass count coding.
struct pass_count_info_t {
    /// the codeword representing number of passes
    unsigned short codeword;
    
    /// number of bits for the codeword
    unsigned char codeword_bits;
    
    /// base 2 logarithm of the pass count
    unsigned char log2;
};



/// For numbers from 0 to 164, this stores their codeword, size of the 
/// codeword and base 2 logaritm of the number
static const struct pass_count_info_t pass_codewords[165] = {
    {0x0000,  0, 0}, // #0 => invalid,
    {0x0000,  1, 0}, // #1 => 0,
    {0x0002,  2, 1}, // #2 => 10,
    {0x000c,  4, 1}, // #3 => 1100,
    {0x000d,  4, 2}, // #4 => 1101,
    {0x000e,  4, 2}, // #5 => 1110,
    {0x01e0,  9, 2}, // #6 => 111100000,
    {0x01e1,  9, 2}, // #7 => 111100001,
    {0x01e2,  9, 3}, // #8 => 111100010,
    {0x01e3,  9, 3}, // #9 => 111100011,
    {0x01e4,  9, 3}, // #10 => 111100100,
    {0x01e5,  9, 3}, // #11 => 111100101,
    {0x01e6,  9, 3}, // #12 => 111100110,
    {0x01e7,  9, 3}, // #13 => 111100111,
    {0x01e8,  9, 3}, // #14 => 111101000,
    {0x01e9,  9, 3}, // #15 => 111101001,
    {0x01ea,  9, 4}, // #16 => 111101010,
    {0x01eb,  9, 4}, // #17 => 111101011,
    {0x01ec,  9, 4}, // #18 => 111101100,
    {0x01ed,  9, 4}, // #19 => 111101101,
    {0x01ee,  9, 4}, // #20 => 111101110,
    {0x01ef,  9, 4}, // #21 => 111101111,
    {0x01f0,  9, 4}, // #22 => 111110000,
    {0x01f1,  9, 4}, // #23 => 111110001,
    {0x01f2,  9, 4}, // #24 => 111110010,
    {0x01f3,  9, 4}, // #25 => 111110011,
    {0x01f4,  9, 4}, // #26 => 111110100,
    {0x01f5,  9, 4}, // #27 => 111110101,
    {0x01f6,  9, 4}, // #28 => 111110110,
    {0x01f7,  9, 4}, // #29 => 111110111,
    {0x01f8,  9, 4}, // #30 => 111111000,
    {0x01f9,  9, 4}, // #31 => 111111001,
    {0x01fa,  9, 5}, // #32 => 111111010,
    {0x01fb,  9, 5}, // #33 => 111111011,
    {0x01fc,  9, 5}, // #34 => 111111100,
    {0x01fd,  9, 5}, // #35 => 111111101,
    {0x01fe,  9, 5}, // #36 => 111111110,
    {0xff80, 16, 5}, // #37 => 1111111110000000,
    {0xff81, 16, 5}, // #38 => 1111111110000001,
    {0xff82, 16, 5}, // #39 => 1111111110000010,
    {0xff83, 16, 5}, // #40 => 1111111110000011,
    {0xff84, 16, 5}, // #41 => 1111111110000100,
    {0xff85, 16, 5}, // #42 => 1111111110000101,
    {0xff86, 16, 5}, // #43 => 1111111110000110,
    {0xff87, 16, 5}, // #44 => 1111111110000111,
    {0xff88, 16, 5}, // #45 => 1111111110001000,
    {0xff89, 16, 5}, // #46 => 1111111110001001,
    {0xff8a, 16, 5}, // #47 => 1111111110001010,
    {0xff8b, 16, 5}, // #48 => 1111111110001011,
    {0xff8c, 16, 5}, // #49 => 1111111110001100,
    {0xff8d, 16, 5}, // #50 => 1111111110001101,
    {0xff8e, 16, 5}, // #51 => 1111111110001110,
    {0xff8f, 16, 5}, // #52 => 1111111110001111,
    {0xff90, 16, 5}, // #53 => 1111111110010000,
    {0xff91, 16, 5}, // #54 => 1111111110010001,
    {0xff92, 16, 5}, // #55 => 1111111110010010,
    {0xff93, 16, 5}, // #56 => 1111111110010011,
    {0xff94, 16, 5}, // #57 => 1111111110010100,
    {0xff95, 16, 5}, // #58 => 1111111110010101,
    {0xff96, 16, 5}, // #59 => 1111111110010110,
    {0xff97, 16, 5}, // #60 => 1111111110010111,
    {0xff98, 16, 5}, // #61 => 1111111110011000,
    {0xff99, 16, 5}, // #62 => 1111111110011001,
    {0xff9a, 16, 5}, // #63 => 1111111110011010,
    {0xff9b, 16, 6}, // #64 => 1111111110011011,
    {0xff9c, 16, 6}, // #65 => 1111111110011100,
    {0xff9d, 16, 6}, // #66 => 1111111110011101,
    {0xff9e, 16, 6}, // #67 => 1111111110011110,
    {0xff9f, 16, 6}, // #68 => 1111111110011111,
    {0xffa0, 16, 6}, // #69 => 1111111110100000,
    {0xffa1, 16, 6}, // #70 => 1111111110100001,
    {0xffa2, 16, 6}, // #71 => 1111111110100010,
    {0xffa3, 16, 6}, // #72 => 1111111110100011,
    {0xffa4, 16, 6}, // #73 => 1111111110100100,
    {0xffa5, 16, 6}, // #74 => 1111111110100101,
    {0xffa6, 16, 6}, // #75 => 1111111110100110,
    {0xffa7, 16, 6}, // #76 => 1111111110100111,
    {0xffa8, 16, 6}, // #77 => 1111111110101000,
    {0xffa9, 16, 6}, // #78 => 1111111110101001,
    {0xffaa, 16, 6}, // #79 => 1111111110101010,
    {0xffab, 16, 6}, // #80 => 1111111110101011,
    {0xffac, 16, 6}, // #81 => 1111111110101100,
    {0xffad, 16, 6}, // #82 => 1111111110101101,
    {0xffae, 16, 6}, // #83 => 1111111110101110,
    {0xffaf, 16, 6}, // #84 => 1111111110101111,
    {0xffb0, 16, 6}, // #85 => 1111111110110000,
    {0xffb1, 16, 6}, // #86 => 1111111110110001,
    {0xffb2, 16, 6}, // #87 => 1111111110110010,
    {0xffb3, 16, 6}, // #88 => 1111111110110011,
    {0xffb4, 16, 6}, // #89 => 1111111110110100,
    {0xffb5, 16, 6}, // #90 => 1111111110110101,
    {0xffb6, 16, 6}, // #91 => 1111111110110110,
    {0xffb7, 16, 6}, // #92 => 1111111110110111,
    {0xffb8, 16, 6}, // #93 => 1111111110111000,
    {0xffb9, 16, 6}, // #94 => 1111111110111001,
    {0xffba, 16, 6}, // #95 => 1111111110111010,
    {0xffbb, 16, 6}, // #96 => 1111111110111011,
    {0xffbc, 16, 6}, // #97 => 1111111110111100,
    {0xffbd, 16, 6}, // #98 => 1111111110111101,
    {0xffbe, 16, 6}, // #99 => 1111111110111110,
    {0xffbf, 16, 6}, // #100 => 1111111110111111,
    {0xffc0, 16, 6}, // #101 => 1111111111000000,
    {0xffc1, 16, 6}, // #102 => 1111111111000001,
    {0xffc2, 16, 6}, // #103 => 1111111111000010,
    {0xffc3, 16, 6}, // #104 => 1111111111000011,
    {0xffc4, 16, 6}, // #105 => 1111111111000100,
    {0xffc5, 16, 6}, // #106 => 1111111111000101,
    {0xffc6, 16, 6}, // #107 => 1111111111000110,
    {0xffc7, 16, 6}, // #108 => 1111111111000111,
    {0xffc8, 16, 6}, // #109 => 1111111111001000,
    {0xffc9, 16, 6}, // #110 => 1111111111001001,
    {0xffca, 16, 6}, // #111 => 1111111111001010,
    {0xffcb, 16, 6}, // #112 => 1111111111001011,
    {0xffcc, 16, 6}, // #113 => 1111111111001100,
    {0xffcd, 16, 6}, // #114 => 1111111111001101,
    {0xffce, 16, 6}, // #115 => 1111111111001110,
    {0xffcf, 16, 6}, // #116 => 1111111111001111,
    {0xffd0, 16, 6}, // #117 => 1111111111010000,
    {0xffd1, 16, 6}, // #118 => 1111111111010001,
    {0xffd2, 16, 6}, // #119 => 1111111111010010,
    {0xffd3, 16, 6}, // #120 => 1111111111010011,
    {0xffd4, 16, 6}, // #121 => 1111111111010100,
    {0xffd5, 16, 6}, // #122 => 1111111111010101,
    {0xffd6, 16, 6}, // #123 => 1111111111010110,
    {0xffd7, 16, 6}, // #124 => 1111111111010111,
    {0xffd8, 16, 6}, // #125 => 1111111111011000,
    {0xffd9, 16, 6}, // #126 => 1111111111011001,
    {0xffda, 16, 6}, // #127 => 1111111111011010,
    {0xffdb, 16, 7}, // #128 => 1111111111011011,
    {0xffdc, 16, 7}, // #129 => 1111111111011100,
    {0xffdd, 16, 7}, // #130 => 1111111111011101,
    {0xffde, 16, 7}, // #131 => 1111111111011110,
    {0xffdf, 16, 7}, // #132 => 1111111111011111,
    {0xffe0, 16, 7}, // #133 => 1111111111100000,
    {0xffe1, 16, 7}, // #134 => 1111111111100001,
    {0xffe2, 16, 7}, // #135 => 1111111111100010,
    {0xffe3, 16, 7}, // #136 => 1111111111100011,
    {0xffe4, 16, 7}, // #137 => 1111111111100100,
    {0xffe5, 16, 7}, // #138 => 1111111111100101,
    {0xffe6, 16, 7}, // #139 => 1111111111100110,
    {0xffe7, 16, 7}, // #140 => 1111111111100111,
    {0xffe8, 16, 7}, // #141 => 1111111111101000,
    {0xffe9, 16, 7}, // #142 => 1111111111101001,
    {0xffea, 16, 7}, // #143 => 1111111111101010,
    {0xffeb, 16, 7}, // #144 => 1111111111101011,
    {0xffec, 16, 7}, // #145 => 1111111111101100,
    {0xffed, 16, 7}, // #146 => 1111111111101101,
    {0xffee, 16, 7}, // #147 => 1111111111101110,
    {0xffef, 16, 7}, // #148 => 1111111111101111,
    {0xfff0, 16, 7}, // #149 => 1111111111110000,
    {0xfff1, 16, 7}, // #150 => 1111111111110001,
    {0xfff2, 16, 7}, // #151 => 1111111111110010,
    {0xfff3, 16, 7}, // #152 => 1111111111110011,
    {0xfff4, 16, 7}, // #153 => 1111111111110100,
    {0xfff5, 16, 7}, // #154 => 1111111111110101,
    {0xfff6, 16, 7}, // #155 => 1111111111110110,
    {0xfff7, 16, 7}, // #156 => 1111111111110111,
    {0xfff8, 16, 7}, // #157 => 1111111111111000,
    {0xfff9, 16, 7}, // #158 => 1111111111111001,
    {0xfffa, 16, 7}, // #159 => 1111111111111010,
    {0xfffb, 16, 7}, // #160 => 1111111111111011,
    {0xfffc, 16, 7}, // #161 => 1111111111111100,
    {0xfffd, 16, 7}, // #162 => 1111111111111101,
    {0xfffe, 16, 7}, // #163 => 1111111111111110,
    {0xffff, 16, 7}, // #164 => 1111111111111111,
}; // end of static const pass_count_info_t pass_codewords[165]



inline int max(const int a, const int b) { return (a > b) ? a : b; }



/// Encodes Pass count and byte size of some codeblock.
/// @param pass_count  number of passes
/// @param byte_count  size in bytes
/// @param encoder     encoder of bits
inline void t2_cpu_codeword_encode(const unsigned char pass_count,
                                   const unsigned int byte_count,
                                   t2_cpu_output_t * encoder) {
    // get variable codeword, its size (in bits) and floor(log2(pass_count))
    const struct pass_count_info_t * const cwd = pass_codewords + pass_count;
    
    // encode the codeword
    encoder->put_bits(cwd->codeword, cwd->codeword_bits);
    
    // Minimal number of bits implied by standard.
    const int byte_count_min_bits = 3 + cwd->log2;
    
    // determine, how many bits are needed to encode the byte count
    const int byte_count_bits_encoded = max(bits_needed(byte_count),
                                            byte_count_min_bits);
    
    // if needed more extra bits than the number implied by standard (depending 
    // on number of passes), signalize this by string of 1s terminated by 0
    encoder->put_ones(byte_count_bits_encoded - byte_count_min_bits);
    encoder->put_zero();

    // now, encode the number of bytes itself
    encoder->put_bits(byte_count, byte_count_bits_encoded);
}



#endif // T2_CPU_CODEWORDS_H



